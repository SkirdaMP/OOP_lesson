# Теория ООП


***Объект* в понятиях разработки ПО является примерно тем же объектом, что и в 
реальной жизни**. Но если реальный объект можно потрогать, увидеть или физически с
ним повзаимодействовать, то объект с точки зрения разработки ПО - это набор **данных**
и **поведений**, связанных с этими данными.

Тогда что значит объекто-ориентированный? **Объектно-ориентированность означает  функциональность направленную на моделируемый объект.**

Объектно-ориентированный подход - это один из *многих* подходов к проектированию сложных систем путем описания множества взаимодействующих объектов через их данные и поведение.

Объектно-ориентированные подход включаетс в себя:
- Объектно-ориентированный анализ 
- Объектно-ориентированный дизайн
- Объектно-ориентированное программирование

Рассмотрим каждый пункт подробнее.

## Объектно-ориентированный анализ
*Это процесс изучения проблемы, системы или задачи (или что-то иное для внедрения в приложение) и идентификации объектов и взаимодействия между объектами.* Это этап определяющий ***что*** нужно реализовать.

Результатом выполнения этапа анализа будет набор требований. Например, в результате этапа анализа задача `Создать сайт` превратится в следующие требования:

- Посетитель сайта должен иметь возможность:
    - *Просмотреть*  нашу **историю**
    - *Утверждения* для **работ**
    - *Просматривать*, *сравнивать* и *сортировать* продукты

В некоторм смысле анализ - неправильная формулировка. Больше подходит термин *исследование*. В разработке приложений начальная стадия анализа - это общение с пользователями, выявление потребностей и изучение их процессов.

Следующий этап это объектно-ориентированный дизайн

## Объектно-ориетированный дизайн
*Это процесс преобразования требований в спецификацию реализации.* Архитектор должен дать имена объектов, определить взаимоотношения и формально указать, как объекты взаимодействуют друг с другом. Этап дизайна описывает всё о том **как** системы должна быть реализована.

Итогом этапа дизайна является набор спецификаций для реализации. Если мы закончили этап дизайна, то набор требований должен стать набором классов, интерфейсов и поведений, которые в идеале должны быть реализованы на каком-то языке программирования.

## Объектно-ориентированное программирование

*Это процесс преобразования спецификаций реализации в работающую программу, которая делает именно то, что просил CEO компании.*

Было бы прекрасно, если бы этапы следовали один за другим и в итоге получался бы замечательный продукт, но разработка ПО в 2021 веке более сложный процесс и поэтому процесс выглядит итерративно, т.е во время разработки открываются вещи, которые не были предусмотрены в дизайне и дизайн доделывается. Так же могут появляться новые требования, тогда производится анализ, обновляется дизайн и доделывается функционал в коде.

## Объекты и классы

Объект - это набор данных и поведений. Появляется вопрос: как сравнивать типы объектов. В реальной жизни есть множество объектов, например "яблоко" и "апельсин", но их нельзя сравнить. Представим, например, что мы моделируем фруктовый склад. Тогда у нас будет 4 объекта: яблоко, апельсин, корзина и коробка. Теперь у нас есть 4 различных объекта.

***В объектно-ориентированном моделировании термин обозначающий тип объекта это - `класс`***

Т.е в технических терминах у нас сейчас есть 4 класса объектов.

Определим разницу между классами и объектами. Классы определяют объекты. Классы - это как чертежи для создания объектов. Сами объекты могут иметь разные характеристики, но бызовые состовляющие объекта определяются классом.

То, как различные классы соотносятся друг с другом можно изобразить на `UML-диаграме`. Это хороший способ первичного дизайна разрабатываемой системы.

## Определение аттрибутов и поведений
Объекты - это экземпляры класса и объекты могут быть связаны друг с другом. Каждый экземпляр - это уникальный объект со своим набором данных и поведений. Выглядит просто, но что это за "данные" и "поведения", которые связаны с объектом.

**Данные обычно представляют индивидуальные характеристики определенного объекта.** Класс может определять наборы характеристик, которые являются общими для всех объектов этого класса.

Любой конкретный объект может иметь разные значения данных для заданных `аттрибутов`.
Атрибуты так же могут быть равными по значениям у разных объектов. 

Аттрибуты часто называют **свойствами**.
Некоторые исследователи говорят, что эти термины имеют разные значения. *Аттрибуты* - это те данные, которые можно *установить* для объекта, а *свойства* - это данные, которые можно только *читать*.

**Поведения - это действия, которые могут происходить с объектом. Поведение, которое может быть выполнено определенным объектом называется `метод`.** С точки зрения программирования, метод это та же самая функция, но которая имеет доступ ко всем данным объекта. Как и функции, методы могут принимать параметры и возвращать значения.

## Сокрытие деталей и создание публичного интерфейса

Основная цель моделирования объекта в объектно-ориентированном проектировании состоит в том, чтобы определить, каким будет открытый интерфейс этого объекта. **Интерфейс - это набор атрибутов и методов, которые другие объекты могут использовать для взаимодействия с этим объектом.** Пользователю не нужно знать о внутреенней реализации объекта, для пользователя важен только внешний интерфейс общения с объектом. Процесс сокрытия реализации или деталей функциональности называется **сокрытие данных** или просто **сокрытие**. Это понятие часто путают с инкапсуляцией, но инкапсуляция - это более широкое понятие.

**Инкапсуляция - это механизм языка, позволяющий объеденить данные и методы, работающие с этими данными в единый объект, и скрыть детали реализации для пользователя.**

А в языке Python в принципе нет (или почти нет) механизма сокрытия данных.

Но публичный интерфейс - это очень важно. Он должен быть детально спроектирован, так как в будущем реализацию интерфейса будет трудно изменить. Эти сложности связаны с тем, что изменения в интерфейсе могуть сломать клиентские приложения, использующие этот объект с публичным интерфейсом. С другой стороны, если мы изменим интерфейс, изменив имена атрибутов, к которым открыт доступ, или изменив порядок или типы аргументов, которые может принимать метод, все клиентские объекты также должны быть изменены. Что касается темы общедоступных интерфейсов, то делайте это просто. **Всегда разрабатывайте интерфейс объекта, основываясь на том, насколько он прост в использовании, а не на том, насколько сложно его кодировать (этот совет также применим к пользовательским интерфейсам).**


## Принципы ООП

Для построения хороших приложений в ОО стиле нужно понимать каким образом объекты могут взаимодействовать друг с другом.
Для налаживания эффективного взаимодействия используются ***принципы проектирования***. Но нужно понимать на чем основаны принципы. И чаще всего это две базовых принципа ООП, а именно: **композиция** и **наследование**.

Подробнее про каждую из них.

### Композиция

**Композиция** - это процес собирания похожих объектов вместе, чтобы создать новый объект.
Композиция это часто хороший выбор, когда один объект является частью другого объекта.
Хорошим примером является автомобиль. Автомобиль состоит из двигателя, коробки передач, стартера, фар и лобового стекла, а также множества других деталей. Двигатель, в свою очередь, состоит из поршней, коленчатого вала и клапанов. В этом примере *композиция* - это отличный способ обеспечить нужный уровень абстракции.

Это обычный вводный пример композиции, но он не слишком полезен, когда дело доходит до проектирования компьютерных систем. Физические объекты легко разбить на составные объекты. Люди делают это, по крайней мере, с тех пор, как древние греки первоначально постулировали, что атомы являются мельчайшими единицами материи (у них, конечно, не было доступа к ускорителям частиц). Компьютерные системы, как правило, менее сложны, чем физические объекты, однако идентификация составляющих объектов в таких системах происходит не так естественно.

Приведем пример более компьютеро-ориентированного примера для того, чтобы показать композицию в действии.

Попробуем спроектировать компьютерную версию шахмат. Это очень простой пример, но он будет довольно показательным.
В качестве базового анализа высокого уровня игра в шахматы проводится между двумя игроками с использованием шахматного набора, состоящего из доски, содержащей шестьдесят четыре позиции в сетке 8 Х 8. На доске может быть два набора из шестнадцати фигур, которые могут перемещаться поочередно двумя игроками разными способами. Каждая фигура может принимать другие фигуры. Доска должна будет рисовать себя на экране компьютера после каждого хода.

Таким образом, шахматный набор состоит из доски и 32 фигур. Кроме того, в состав доски  входят 64 позиции. Вы можете возразить, что фигуры не являются частью шахматного набора, потому что вы могли бы заменить фигуры в шахматном наборе другим набором фигур. 
Хотя это маловероятно или невозможно в компьютерной версии шахмат, это знакомит нас с ***агрегацией***.

Агрегация очень похожа на композицию. Рзница в том, что если составной (внешний) объект управляет созданием и уничтожением связанных (внутренних) объектов, наиболее подходящей является композиция. Если связанный объект создается независимо от составного объекта или может пережить этот объект, агрегация имеет больше смысла.

В принципе, композиция - это практически агрегация. **Агрегация-это просто более общая форма композиции. Любые композитные отношения также являются агрегатными отношениями, но не наоборот.**

Давайте обсудим текущий шахматный набор, чтобы объяснить все взаимоотношения и атрибуты.
![UML-diagram chess set](IMG_20220129_123337.jpg)


Композиционные отношения представлены в UML в виде сплошного алмаза. Полый алмаз представляет совокупную взаимосвязь. Вы заметите, что доска и фигуры хранятся как часть шахматного набора точно так же, как ссылка на них хранится в качестве атрибута шахматного набора. Это еще раз показывает, что на практике различие между агрегацией и композицией часто не имеет значения, как только вы пройдете стадию проектирования. При внедрении они ведут себя примерно так же. 

### Наследование

